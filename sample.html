<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <meta name="author" content="Nicolas Di Prima" />
  <title>Haskell's Nat</title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
  </style>
</head>
<body>
<div id="header">
<h1 class="title">Haskell's Nat</h1>
<h2 class="author">Nicolas Di Prima</h2>
</div>
<p>I recently started to play with haskell's <a href="//www.stackage.org/haddock/lts-8.5/base-4.9.1.0/GHC-TypeLits.html">Type Literals</a>, you can have a look at my <a href="//github.com/haskell-crypto/cryptonite/pull/140">PR in cryptonite</a>.</p>
<p>GHC's <em>Type Literals</em> enables a new world of possibility in APIs and to solve day to day developers issues.</p>
<h2 id="blake2">Blake2</h2>
<p>Blake2b is a cryptographic hash (with <a href="//tools.ietf.org/html/rfc7693">interesting properties</a>). One of them is that it can generate digest from 8 bits long to 512bits long as long as it is divisible by 8 ; i.e. digest's size from 1 byte to 64 bytes.</p>
<p>Cryptonite legacy APIs provides a <a href="https://www.stackage.org/haddock/lts-8.5/cryptonite-0.21/Crypto-Hash-Algorithms.html#t:Blake2b_512">set of known digests</a> but ideally, we would like to enable every digest size possible without having to create a 64 different types.</p>
<h2 id="the-other-languages">The other languages</h2>
<h3 id="rust">Rust</h3>
<p>In <strong>Rust</strong> we would create a generic struct.</p>
<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">struct</span> Digest&lt;S: <span class="dt">usize</span>&gt;([<span class="dt">u8</span>;S]);</code></pre></div>
<p>We would still have to perform some dynamic check on <code>S</code> to validate it is within 1 to 64.</p>
<h3 id="c">C++</h3>
<p>In <strong>C++</strong> we would use templates and some <code>static_assert</code>:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span>&lt;size_t S&gt;
<span class="kw">struct</span> Digest {
  <span class="kw">static_assert</span>(S &gt; <span class="dv">0</span> &amp;&amp; S &lt; <span class="dv">513</span>, <span class="st">&quot;invalid digest size&quot;</span>);
  <span class="kw">static_assert</span>(S % <span class="dv">8</span> == <span class="dv">0</span>, <span class="st">&quot;digest not a multiple of 8.&quot;</span>)
  std::array&lt;<span class="dt">uint8_t</span>, S / <span class="dv">8</span>&gt; digest;
};</code></pre></div>
<h2 id="haskell">Haskell</h2>
<p>Haskell comes with a brilliant idea, equivalent to the <strong>C++</strong> solution (to a certain extent), the <strong>Type Literals</strong>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- the type we are interested about today</span>
<span class="kw">data</span> <span class="dt">Nat</span><span class="ot"> ::</span> <span class="fu">*</span>
<span class="co">-- a class to limit our type literal to</span>
<span class="kw">class</span> <span class="dt">KnownNat</span> n</code></pre></div>
<p>Exactly, it allows you to write literals in your types, and to be able to retrieve the value at runtime.</p>
<p>So in our case we could write:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- we can use the natural like we would use a type parameter.</span>
<span class="kw">data</span> <span class="dt">Blake2b</span> (<span class="ot">n ::</span> <span class="dt">Nat</span>) <span class="fu">=</span> <span class="dt">Blake2b</span>

<span class="co">-- we can add condition</span>
<span class="kw">class</span> (<span class="dt">KnownNat</span> bitlen, <span class="dv">8</span> <span class="fu">&lt;=</span> bitlen, bitlen <span class="fu">&lt;=</span> <span class="dv">512</span>) <span class="ot">=&gt;</span> <span class="dt">Algorithm</span> (<span class="dt">Blake2b</span> bitlen) <span class="kw">where</span>
    <span class="co">-- ...</span></code></pre></div>
<p><strong>GHC</strong> will fail to compile any code making use of the <code>Bloke2b 1024</code> (or any other invalid value).</p>
<p>The only down side is that it is still missing a proper clean error message to help developers. This is still possible. Since <code>ghc 8.0.1</code> we can define a type error.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- we define a new type operator that will call a helper type family</span>
<span class="kw">type</span> <span class="dt">IsAtMost</span> (<span class="ot">bitlen ::</span> <span class="dt">Nat</span>) (<span class="ot">n ::</span> <span class="dt">Nat</span>) <span class="fu">=</span> <span class="dt">IsLE</span> bitlen n (bitlen <span class="fu">&lt;=?</span> n) <span class="fu">~</span> <span class="ch">&#39;True</span>

<span class="kw">type</span> family <span class="dt">IsLE</span> (<span class="ot">bitlen ::</span> <span class="dt">Nat</span>) (<span class="ot">n ::</span> <span class="dt">Nat</span>) (<span class="ot">c ::</span> <span class="dt">Bool</span>) <span class="kw">where</span>
    <span class="dt">IsLE</span> bitlen n <span class="ch">&#39;True  = &#39;</span><span class="dt">True</span>
    <span class="dt">IsLE</span> bitlen n <span class="ch">&#39;False = TypeError</span>
      (     (<span class="ch">&#39;Text &quot;bitlen &quot; &#39;</span><span class="fu">:&lt;&gt;:</span> <span class="ch">&#39;ShowType bitlen &#39;</span><span class="fu">:&lt;&gt;:</span> <span class="ch">&#39;Text &quot; is greater than &quot; &#39;</span><span class="fu">:&lt;&gt;:</span> <span class="ch">&#39;ShowType n)</span>
      <span class="ch">&#39;:$$: (&#39;</span><span class="dt">Text</span> <span class="st">&quot;You have tried to use an invalid Digest size. Please, refer to the documentation.&quot;</span>)
      )</code></pre></div>
<p>We still perform the <code>&lt;=?</code> type operator but we pass the result to our type family and then we pattern match on it.</p>
</body>
</html>
